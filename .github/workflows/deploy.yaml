name: jetbrain devops task

on:
  push:
    branches:
      - 'feature/**'
      - 'dev/**'
  pull_request:
    types: [ closed ]
    branches:
      - stage

  workflow_dispatch:
    inputs:
      approve:
        description: "Type 'YES' to confirm production deployment"
        required: true

permissions: #This gives the repoâ€™s GITHUB_TOKEN the rights to push to GHCR from Actions.
  contents: read
  packages: write
env:
  REGISTRY: ghcr.io/mina-farajian/jetbrain-task
  STAGE_NS: staging
  PROD_NS: production

jobs:
  build-and-push:
   if: github.event_name != 'workflow_dispatch' || github.event.inputs.approve != 'yes'
   runs-on: ubuntu-latest
   outputs:
     safe_branch: ${{ steps.branch.outputs.safe_branch }}
   steps:
     - name: Checkout Code
       uses: actions/checkout@v3

     - name: Set up QEMU (for cross-platform builds)
       uses: docker/setup-qemu-action@v2

     - name: Set up Docker Buildx   #allows multi-platform builds, caching, and advanced Docker features.
       uses: docker/setup-buildx-action@v3

     - name: Get branch name
       id: branch
       run: |
          BRANCH="${GITHUB_REF_NAME}"
          SAFE_BRANCH=$(echo "$BRANCH" | tr '[:upper:]' '[:lower:]' \
                        | sed 's#[/_]#-#g' | sed 's#[^a-z0-9-]##g')
          echo "safe_branch=$SAFE_BRANCH" >> $GITHUB_OUTPUT

     - name: Login to GHCR
       uses: docker/login-action@v2
       with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

     - name: Check if image exists in GHCR
       id: check-image
       run: |
         IMAGE="ghcr.io/${{ github.repository_owner }}/jetbrain-task:${{ github.sha }}"
         echo "Checking if $IMAGE exists..."
         if docker manifest inspect "$IMAGE" >/dev/null 2>&1; then
           echo "exists=true" >> $GITHUB_OUTPUT
         else
           echo "exists=false" >> $GITHUB_OUTPUT
         fi

#     - name: Build and push
#       id: build
#       if: steps.check-image.outputs.exists == 'false'
#       uses: docker/build-push-action@v4
#       with:
#          context: .
#          file: ./Dockerfile
#          push: true
#          platforms: linux/amd64
#          tags: |
#            ${{env.REGISTRY}}:dev-${{ steps.branch.outputs.safe_branch }}-${{ github.sha }}
#            ${{env.REGISTRY}}:${{ github.sha }}

     - name: Build and push (dev/feature)
       id: build-dev
       if: steps.check-image.outputs.exists == 'false' &&
         (startsWith(github.ref, 'refs/heads/feature/') || startsWith(github.ref, 'refs/heads/dev/'))
       uses: docker/build-push-action@v4
       with:
         context: .
         file: ./Dockerfile
         push: true
         platforms: linux/amd64
         tags: |
           ${{ env.REGISTRY }}:dev-${{ steps.branch.outputs.safe_branch }}-${{ github.sha }}

     - name: Build and push (stage)
       id: build-stage
       if: steps.check-image.outputs.exists == 'false' && github.ref == 'refs/heads/stage'
       uses: docker/build-push-action@v4
       with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}:${{ github.sha }}   

     - name: Run Trivy vulnerability scanner
       uses: aquasecurity/trivy-action@0.29.0
       with:
             image-ref: ${{env.REGISTRY}}:${{ github.sha }}
             format: 'table'
             ignore-unfixed: true #if find high and critical issue exists pipeline will be stopped
             vuln-type: 'os,library'
             severity: 'CRITICAL,HIGH'
             cache: 'true'
             output: trivy.txt


     - name: Publish Trivy Output to Summary
       run: |
           if [[ -s trivy.txt ]]; then
             {
               echo "### Security Output"
               echo "<details><summary>Click to expand</summary>"
               echo ""
               echo '```terraform'
               cat trivy.txt
               echo '```'
               echo "</details>"
             } >> $GITHUB_STEP_SUMMARY
           fi

#################################################### Dev ############################################################################################
  deploy-dev:
       needs: build-and-push
       if: startsWith(github.ref, 'refs/heads/feature/') || startsWith(github.ref, 'refs/heads/dev/')
       runs-on: ubuntu-latest
       env:
         IMAGE_TAG: dev-${{ needs.build-and-push.outputs.safe_branch }}-${{ github.sha }}
         NAMESPACE: dev-${{ needs.build-and-push.outputs.safe_branch }}
       steps:
         - name: Checkout repository
           uses: actions/checkout@v3

         - name: Set up Kubeconfig
           run: |
             mkdir -p ~/.kube
             echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > ~/.kube/config
             chmod 600 ~/.kube/config

         - name: Deploy to Staging with Helm
           run: |
             echo "$REGISTRY"
             echo "Deploying image: $REGISTRY/$IMAGE_TAG to namespace $NAMESPACE"
             
             helm upgrade --install my-app ./charts \
               --namespace $NAMESPACE \
               --create-namespace \
               --set image.repository=$REGISTRY \
               --set image.tag=${IMAGE_TAG} \
               -f charts/values-dev.yaml

############################################### Stage #################################################################################################

  deploy-staging:
     needs: build-and-push
     if: github.ref == 'refs/heads/stage'
     runs-on: ubuntu-latest
     outputs:
       image-tag: ${{ env.IMAGE_TAG }}
     env:
      IMAGE_TAG: ${{ github.sha }}
      NAMESPACE: staging
     steps:
         - name: Checkout repository
           uses: actions/checkout@v3

         - name: Set up Kubeconfig
           run: |
             mkdir -p ~/.kube
             echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > ~/.kube/config
             chmod 600 ~/.kube/config

         - name: Deploy to Staging
           run: |
            echo "Deploying image: ${{ env.REGISTRY }}:${{ env.IMAGE_TAG }} to staging"

            helm upgrade --install my-app ./charts \
            --namespace ${{ env.STAGE_NS}} \
            --set image.repository=${{ env.REGISTRY }} \
            --set image.tag=${{ env.IMAGE_TAG }} \
            -f charts/values-stage.yaml
             
#         - name: Run smoke tests
#           run: |
#             kubectl -n staging port-forward svc/my-service-stage 8080:8000 &
#             sleep 5
#             curl -f http://127.0.0.1:8080/
################################################# Production ###############################################################################################

  deploy-production:
     if: github.event_name == 'workflow_dispatch'
     runs-on: ubuntu-latest
     permissions:
      issues: write
     concurrency: production  # Prevent multiple prod deploys at same time
     env:
       name: production
       IMAGE_TAG: ${{ needs.deploy-staging.outputs.image-tag }}
       url: https://your-production-url.com

     steps:
       - name: Await Manual Approval
         uses: trstringer/manual-approval@v1
         with:
           secret: ${{ secrets.GITHUB_TOKEN }}
           approvers: Mina-Farajian
           minimum-approvals: 1
           issue-title: "Manual Approval Required for Production deploy"
           issue-body: "Please approve or deny the deployment."

       - name: Checkout repository
         uses: actions/checkout@v3

       - name: Verify Staging Image Exists
         run: |
           IMAGE="${{ env.REGISTRY }}:${{ env.IMAGE_TAG }}"
           echo "Checking $IMAGE..."
           if docker manifest inspect "$IMAGE" >/dev/null 2>&1; then
             echo "Image exists; proceeding."
           else
             echo "ERROR: $IMAGE not found in GHCR. Make sure this SHA is the one built/deployed to staging."
             exit 1
           fi
       - name: Set up Kubeconfig
         run: |
           mkdir -p ~/.kube
           echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > ~/.kube/config
           chmod 600 ~/.kube/config

       - name: Deploy to Production with Helm
         run: |
           IMAGE_TAG=${{ github.sha }}
           echo "Deploying image: ${{ env.REGISTRY }}/${{ env.IMAGE_TAG }} to ${{ env.PROD_NS }}"

           helm upgrade --install my-app ./charts \
             --namespace ${{ env.PROD_NS}} \
             --set image.repository=${{ env.REGISTRY }} \
             --set image.tag=${IMAGE_TAG} \
             -f charts/values-prod.yaml
